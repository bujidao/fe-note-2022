# 为什么选vite

## 现实问题

在浏览器支持ES模块以前，JavaScript并没有提供原生机制让开发者以模块化的方式进行开发。这也是我们对“打包”这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。

时过境迁，我们见证了诸如 webpack、Rollup、Parcel 等工具的变迁，他们极大的改善了前端开发者的开发体验。

然而，当我们开始构建越来越大的大型应用时，需要处理的javascript代码量也呈指数型增长。包含数千个模块的大型项目比比皆是。我们开始遇到性能瓶颈————使用javascript开发的工具通常需要很长的时间，才能启动开发服务，即使使用HMR，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈，极大的影响了开发者的开发效率。

Vite 旨在利用生态系统中的新进展解决上述问题：浏览器开始支持原生ES模块，且越来越多的JavaScript工具使用编译型语言开始编写。

### 缓慢的服务器启动

当冷启动开发服务器的时候，基于打包器的构建方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。

Vite 通过在一开始将应用中的模块区分为 **依赖** 和 **源码** 两类，改进了开发服务器的启动时间。

* **依赖** 大多为在开发的时候，不会变动的纯JavaScript。一些较大的依赖（例如上百个模块的组件库）处理的代价很高。依赖也通常会存在多个模块化格式（ESM/CommonJs）

  Vite 使用 Esbuild 预构建依赖。Exbuild 使用 go 语言编写，并且比以 JavaScript 编写的打包欲构建依赖块10 - 100 倍。

* **源码** 通常包含一些并非直接是 JavaSctipt 的文件，需要转换（JSX、css、Vue组件等），时常会被编辑。同时，并不是所有的源码都需要同时被加载。

  Vite以原生 ESM 方式提供源码。这实际让浏览器接管了打包程序的部分工作：Vite只需要在浏览器请求源码的时候，进行转换，并按需提供源码。根据情形进行动态导入源码，即只在当前屏幕上实际使用时，才会处理。

### 缓慢的更新

基于打包器启动时，重建整个包的效率很低。原因显而易见：更新速度会随着应用体积的增长而下降。

一些打包的开发服务器将构建内容存入内存，这样只需要在文件更改的时候，使模块图的一部分失活，但它仍然需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除当前页面的状态，所以打包器支持了动态模块热重载（HMR）：允许一个模块“热重载”它自己，而不会影响页面的其他部分。这大大改进了开发体验————然而，在实践中发现，即使是采用了HMR模式，其热更新速度也会随着应用体积的增大而降低。

在Vite中，HMR 实在原生 ESM 上执行的。当编译一个文件时，Vite 只需要精确的使已经编辑的模块与其最近的HMR边界的连接失活（大多数只是模块本身），使得无论应用大小如何，HMR 始终能保持快速的更新。

Vite 同时利用 HTTP 头来加速整个页面的重新加载速度（再次让浏览器为我们做更多的事情）：源码模块的请求会根据 `304 Not Modified` 进行协商缓存，而依赖模块请求会通过 `Cache-Control: max-age=31536000,immutable` 进行强缓存，因此一旦被缓存下来，它们不会再次请求。


